
func (c *Client) ProcessElementsFromBottomMultiParent(tx *sqlx.Tx, elementIDs []int64) error {
    traceID := "9caeef90-058f-4667-b117-d25af63fc4cb"
    
    // 1. Получаем ВСЕ уникальные элементы из всех поддеревьев
    allElementsSet := make(map[int64]bool)
    
    for _, elementID := range elementIDs {
        subtree, err := c.getAllElementsInSubtree(tx, elementID)
        if err != nil {
            return fmt.Errorf("failed to get subtree for element %d: %w", elementID, err)
        }
        
        for _, elemID := range subtree {
            allElementsSet[elemID] = true
        }
    }
    
    if len(allElementsSet) == 0 {
        return nil
    }
    
    // Конвертируем set в slice
    allElements := make([]int64, 0, len(allElementsSet))
    for elemID := range allElementsSet {
        allElements = append(allElements, elemID)
    }
    
    // 2. Получаем информацию о элементах
    elementsInfo, err := c.getElementsInfo(tx, allElements)
    if err != nil {
        return err
    }
    
    // 3. Сортируем элементы по рангу (от меньшего к большему)
    sort.Slice(elementsInfo, func(i, j int) bool {
        return elementsInfo[i].Rank < elementsInfo[j].Rank
    })
    
    // 4. Обрабатываем элементы в порядке возрастания ранга
    // Для элементов с одинаковым рангом может потребоваться несколько проходов
    processedCount := 0
    maxIterations := len(elementsInfo) * 2 // защита от бесконечного цикла
    
    for iteration := 0; iteration < maxIterations && processedCount < len(elementsInfo); iteration++ {
        for i := range elementsInfo {
            if elementsInfo[i].Processed {
                continue
            }
            
            // Проверяем, можно ли обработать этот элемент
            canProcess := true
            
            // Если это правило, проверяем что все его дети уже обработаны
            if elementsInfo[i].Type == "rule" {
                childrenProcessed, err := c.areAllChildrenProcessed(tx, elementsInfo[i].ID, elementsInfo)
                if err != nil {
                    return err
                }
                canProcess = childrenProcessed
            }
            
            if canProcess {
                // Удаляем из trace
                deleteQuery := `CALL trace.delete_elements_from_trace_force($1, $2)`
                _, err := tx.Exec(deleteQuery, elementsInfo[i].ID, traceID)
                if err != nil {
                    return fmt.Errorf("failed to delete element %d: %w", elementsInfo[i].ID, err)
                }
                
                // Вставляем в trace
                copyQuery := `CALL element.copy_element_to_trace($1, $2, $3)`
                _, err = tx.Exec(copyQuery, elementsInfo[i].ID, "element", traceID)
                if err != nil {
                    return fmt.Errorf("failed to copy element %d: %w", elementsInfo[i].ID, err)
                }
                
                elementsInfo[i].Processed = true
                processedCount++
            }
        }
    }
    
    if processedCount < len(elementsInfo) {
        return fmt.Errorf("failed to process all elements, possibly due to circular dependency")
    }
    
    return nil
}

func (c *Client) getAllElementsInSubtree(tx *sqlx.Tx, startElementID int64) ([]int64, error) {
    var allElements []int64
    
    q := `
    WITH RECURSIVE element_tree(id, path, cycle) AS (
        SELECT 
            id, 
            ARRAY[id],
            false
        FROM element.list 
        WHERE id = $1
        
        UNION ALL
        
        SELECT 
            l.id,
            et.path || l.id,
            l.id = ANY(et.path)
        FROM element.list l
        JOIN element.rule_link rl ON l.id = rl.element_id
        JOIN element_tree et ON et.id = rl.id_rule
        WHERE NOT et.cycle
    )
    SELECT id FROM element_tree WHERE NOT cycle`
    
    err := tx.Select(&allElements, q, startElementID)
    if err != nil && !errors.Is(err, sql.ErrNoRows) {
        return nil, err
    }
    
    return allElements, nil
}

type ElementInfo struct {
    ID        int64  `db:"id"`
    Type      string `db:"type"`
    Rank      int64  `db:"rank"`
    Processed bool   `db:"-"`
}

func (c *Client) getElementsInfo(tx *sqlx.Tx, elementIDs []int64) ([]ElementInfo, error) {
    if len(elementIDs) == 0 {
        return []ElementInfo{}, nil
    }
    
    var elements []ElementInfo
    query, args, err := sqlx.In(`
        SELECT id, type, rank 
        FROM element.list 
        WHERE id IN (?)
        ORDER BY rank ASC`, elementIDs)
    if err != nil {
        return nil, err
    }
    
    query = tx.Rebind(query)
    err = tx.Select(&elements, query, args...)
    if err != nil {
        return nil, err
    }
    
    return elements, nil
}

func (c *Client) areAllChildrenProcessed(tx *sqlx.Tx, elementID int64, elementsInfo []ElementInfo) (bool, error) {
    // Получаем всех детей элемента
    var children []int64
    q := `SELECT element_id FROM element.rule_link WHERE id_rule = $1`
    err := tx.Select(&children, q, elementID)
    if err != nil && !errors.Is(err, sql.ErrNoRows) {
        return false, err
    }
    
    if len(children) == 0 {
        return true, nil
    }
    
    // Проверяем, все ли дети обработаны
    for _, childID := range children {
        childProcessed := false
        for _, info := range elementsInfo {
            if info.ID == childID && info.Processed {
                childProcessed = true
                break
            }
        }
        if !childProcessed {
            return false, nil
        }
    }
    
    return true, nil
}