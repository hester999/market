func (c *Client) ProcessElementsFromBottomMultiParent(tx *sqlx.Tx, elementIDs []int64) error {
    traceID := "9caeef90-058f-4667-b117-d25af63fc4cb"
    
    // 1. Получаем ВСЕ элементы из всех поддеревьев
    allElements := make([]int64, 0)
    elementMap := make(map[int64]bool) // Для отслеживания уникальности
    
    for _, elementID := range elementIDs {
        // Рекурсивно получаем все элементы поддерева
        subtree, err := c.getAllElementsInSubtreeMultiParent(tx, elementID)
        if err != nil {
            return fmt.Errorf("failed to get subtree for element %d: %w", elementID, err)
        }
        
        for _, elemID := range subtree {
            if !elementMap[elemID] {
                elementMap[elemID] = true
                allElements = append(allElements, elemID)
            }
        }
    }
    
    if len(allElements) == 0 {
        return nil
    }
    
    // 2. Получаем информацию о рангах и типах всех элементов
    elementsInfo, err := c.getElementsInfo(tx, allElements)
    if err != nil {
        return err
    }
    
    // 3. Группируем элементы по рангу
    elementsByRank := make(map[int][]int64)
    maxRank := 0
    
    for _, info := range elementsInfo {
        rank := int(info.Rank)
        elementsByRank[rank] = append(elementsByRank[rank], info.ID)
        
        if rank > maxRank {
            maxRank = rank
        }
    }
    
    // 4. Обрабатываем от ранга 0 до maxRank (от листьев к корню)
    for rank := 0; rank <= maxRank; rank++ {
        if elements, ok := elementsByRank[rank]; ok {
            for _, elementID := range elements {
                // Находим тип элемента
                var elementType string
                for _, info := range elementsInfo {
                    if info.ID == elementID {
                        elementType = info.Type
                        break
                    }
                }
                
                // Проверяем, все ли дети уже обработаны (только для правил)
                if elementType == "rule" {
                    allChildrenProcessed, err := c.checkAllChildrenProcessed(tx, elementID, elementsInfo, rank, maxRank)
                    if err != nil {
                        return err
                    }
                    if !allChildrenProcessed {
                        // Пропускаем этот элемент сейчас, обработаем позже
                        continue
                    }
                }
                
                // Удаляем из trace
                deleteQuery := `CALL trace.delete_elements_from_trace_force($1, $2)`
                _, err := tx.Exec(deleteQuery, elementID, traceID)
                if err != nil {
                    return fmt.Errorf("failed to delete element %d: %w", elementID, err)
                }
                
                // Вставляем в trace
                copyQuery := `CALL element.copy_element_to_trace($1, $2, $3)`
                _, err = tx.Exec(copyQuery, elementID, "element", traceID)
                if err != nil {
                    return fmt.Errorf("failed to copy element %d: %w", elementID, err)
                }
                
                // Помечаем как обработанный
                for i := range elementsInfo {
                    if elementsInfo[i].ID == elementID {
                        elementsInfo[i].Processed = true
                        break
                    }
                }
            }
        }
    }
    
    return nil
}

// Получаем все элементы в поддереве с учетом множественных родителей
func (c *Client) getAllElementsInSubtreeMultiParent(tx *sqlx.Tx, startElementID int64) ([]int64, error) {
    var allElements []int64
    
    q := `
    WITH RECURSIVE element_tree AS (
        -- Начинаем с корневого элемента
        SELECT id, rank
        FROM element.list 
        WHERE id = $1
        
        UNION ALL
        
        -- Добавляем детей (множественные родители учитываются)
        SELECT DISTINCT l.id, l.rank
        FROM element.list l
        JOIN element.rule_link rl ON l.id = rl.element_id
        JOIN element_tree et ON et.id = rl.id_rule
        WHERE l.id NOT IN (SELECT id FROM element_tree)
    )
    SELECT id FROM element_tree`
    
    err := tx.Select(&allElements, q, startElementID)
    if err != nil && !errors.Is(err, sql.ErrNoRows) {
        return nil, err
    }
    
    return allElements, nil
}

type ElementInfo struct {
    ID        int64  `db:"id"`
    Type      string `db:"type"`
    Rank      int64  `db:"rank"`
    Processed bool   `db:"-"`
}

// Получаем информацию о всех элементах
func (c *Client) getElementsInfo(tx *sqlx.Tx, elementIDs []int64) ([]ElementInfo, error) {
    if len(elementIDs) == 0 {
        return []ElementInfo{}, nil
    }
    
    var elements []ElementInfo
    query, args, err := sqlx.In(`
        SELECT id, type, rank 
        FROM element.list 
        WHERE id IN (?)
        ORDER BY rank ASC`, elementIDs)
    if err != nil {
        return nil, err
    }
    
    query = tx.Rebind(query)
    err = tx.Select(&elements, query, args...)
    if err != nil {
        return nil, err
    }
    
    return elements, nil
}

// Проверяем, все ли дети элемента уже обработаны
func (c *Client) checkAllChildrenProcessed(tx *sqlx.Tx, elementID int64, elementsInfo []ElementInfo, currentRank, maxRank int) (bool, error) {
    // Получаем всех детей элемента
    var children []int64
    q := `SELECT element_id FROM element.rule_link WHERE id_rule = $1`
    err := tx.Select(&children, q, elementID)
    if err != nil && !errors.Is(err, sql.ErrNoRows) {
        return false, err
    }
    
    // Если детей нет, можно обрабатывать
    if len(children) == 0 {
        return true, nil
    }
    
    // Проверяем каждого ребенка
    for _, childID := range children {
        // Ищем информацию о ребенке
        childProcessed := false
        childRank := -1
        
        for _, info := range elementsInfo {
            if info.ID == childID {
                childProcessed = info.Processed
                childRank = int(info.Rank)
                break
            }
        }
        
        // Если ребенок не найден или не обработан - нельзя обрабатывать родителя
        if childRank == -1 || !childProcessed {
            return false, nil
        }
        
        // Дополнительная проверка: ранг ребенка должен быть больше ранга родителя
        if childRank <= currentRank {
            return false, fmt.Errorf("invalid hierarchy: child rank %d <= parent rank %d", childRank, currentRank)
        }
    }
    
    return true, nil
}