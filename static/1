func (c *Client) ProcessGraphTopological(tx *sqlx.Tx, elementIDs []int64) error {
    traceID := "9caeef90-058f-4667-b117-d25af63fc4cb"
    
    // 1. Строим граф зависимостей
    graph, err := c.buildDependencyGraph(tx, elementIDs)
    if err != nil {
        return err
    }
    
    // 2. Топологическая сортировка (Kahn's algorithm)
    sorted, err := c.topologicalSort(graph)
    if err != nil {
        return fmt.Errorf("circular dependency detected: %w", err)
    }
    
    // 3. Обрабатываем в отсортированном порядке
    for _, elemID := range sorted {
        // Удаляем из trace
        deleteQuery := `CALL trace.delete_elements_from_trace_force($1, $2)`
        _, err := tx.Exec(deleteQuery, elemID, traceID)
        if err != nil {
            return err
        }
        
        // Вставляем в trace
        copyQuery := `CALL element.copy_element_to_trace($1, $2, $3)`
        _, err = tx.Exec(copyQuery, elemID, "element", traceID)
        if err != nil {
            return err
        }
    }
    
    return nil
}

type GraphNode struct {
    ID         int64
    InDegree   int      // количество входящих зависимостей (родителей)
    Children   []int64  // элементы, которые зависят от этого (дети)
    DependsOn  []int64  // элементы, от которых зависит этот (родители)
}

func (c *Client) buildDependencyGraph(tx *sqlx.Tx, startIDs []int64) (map[int64]*GraphNode, error) {
    graph := make(map[int64]*GraphNode)
    
    // Получаем все элементы и связи
    var allElements []struct {
        ID       int64 `db:"id"`
        ParentID int64 `db:"parent_id"`
        ChildID  int64 `db:"child_id"`
    }
    
    query, args, err := sqlx.In(`
    WITH RECURSIVE all_links AS (
        SELECT id_rule as parent_id, element_id as child_id
        FROM element.rule_link 
        WHERE id_rule IN (?)
        
        UNION
        
        SELECT rl.id_rule, rl.element_id
        FROM element.rule_link rl
        JOIN all_links al ON al.child_id = rl.id_rule
    )
    SELECT DISTINCT parent_id, child_id FROM all_links`, startIDs)
    
    if err != nil {
        return nil, err
    }
    
    query = tx.Rebind(query)
    err = tx.Select(&allElements, query, args...)
    if err != nil {
        return nil, err
    }
    
    // Строим граф
    for _, link := range allElements {
        // Узел-родитель
        if _, ok := graph[link.ParentID]; !ok {
            graph[link.ParentID] = &GraphNode{
                ID:        link.ParentID,
                Children:  []int64{},
                DependsOn: []int64{},
            }
        }
        
        // Узел-ребенок
        if _, ok := graph[link.ChildID]; !ok {
            graph[link.ChildID] = &GraphNode{
                ID:        link.ChildID,
                Children:  []int64{},
                DependsOn: []int64{},
            }
        }
        
        // Добавляем связи
        graph[link.ParentID].Children = append(graph[link.ParentID].Children, link.ChildID)
        graph[link.ChildID].DependsOn = append(graph[link.ChildID].DependsOn, link.ParentID)
        graph[link.ChildID].InDegree++
    }
    
    // Добавляем стартовые элементы, если их нет в графе
    for _, id := range startIDs {
        if _, ok := graph[id]; !ok {
            graph[id] = &GraphNode{
                ID:        id,
                Children:  []int64{},
                DependsOn: []int64{},
                InDegree:  0,
            }
        }
    }
    
    return graph, nil
}

func (c *Client) topologicalSort(graph map[int64]*GraphNode) ([]int64, error) {
    var result []int64
    
    // Находим узлы с нулевой входящей степенью
    queue := make([]int64, 0)
    for id, node := range graph {
        if node.InDegree == 0 {
            queue = append(queue, id)
        }
    }
    
    // Процесс топологической сортировки
    for len(queue) > 0 {
        current := queue[0]
        queue = queue[1:]
        result = append(result, current)
        
        // Уменьшаем in-degree у детей
        for _, childID := range graph[current].Children {
            if childNode, ok := graph[childID]; ok {
                childNode.InDegree--
                if childNode.InDegree == 0 {
                    queue = append(queue, childID)
                }
            }
        }
    }
    
    // Проверяем, что все узлы обработаны
    if len(result) != len(graph) {
        // Находим непрошедшие узлы (циклические зависимости)
        remaining := make([]int64, 0)
        for id := range graph {
            found := false
            for _, processedID := range result {
                if processedID == id {
                    found = true
                    break
                }
            }
            if !found {
                remaining = append(remaining, id)
            }
        }
        return nil, fmt.Errorf("circular dependencies involving elements: %v", remaining)
    }
    
    return result, nil
}